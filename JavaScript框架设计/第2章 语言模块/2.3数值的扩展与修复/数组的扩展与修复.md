```js
console.log(0.1 + 0.2) // 0.30000000000000004
console.log(Math.pow(2, 53) === Math.pow(2, 53) + 1) // true
console.log(Infinity > 100) // true
console.log(JSON.stringify(25001509088465005)) // 25001509088465004
```

这些其实不是bug，而是我们无法接受的事实。在js中，数值有3种保存方式：
1. 字符串形式的数值内容
2. IEEE 754标准双精度浮点数，它最多支持小数点后带15-17位小数，由于存在二进制和十进制的转换问题，具体的位数会发生变化
3. 一种类似C语言的int类型的32位整数，它由4个8 bit 的字节构成，可以保存较小的整数

当JS遇到一个数值时，它会首先尝试按整数来处理该数值，如果可行，则把数值存为31 bit的整数；若该数值不能视为整数，或超出31bit范围，则把数值保存为64位IEEE 754浮点数

***什么时候规规矩矩的整数会变成捉摸不定的双精度浮点数？***
答案是：当它们的值变得非常庞大时，或者进入1或0之间，规规矩矩的整数就会变成捉摸不定的双精度浮点数，因此我们需要注意以下数值。

首先是1和0；
其次是最大的Unicode数值 1114111(7位数字，相当于 /x41777777)
最大的RGB颜色值 16777215 (8位数字，相当于 #ffffff)
最大的32bit整数 147483647 (10位数字，即Math.pow(2, 31) - 1)
最小的32bit整数是 -2147483648，因为JS内部会以整数形式保存所有Unicode值和RGB颜色
再次是 2147483647，任何大于该值的数据将保存为双精度格式
最大浮点数 9007199254740992 (16位数字，即Math.pow(2, 53)) 因为输出时类似整数，而所有Date对象都小于该值，因此总是模拟整数的格式输出
最大的双精度数值 1.7976931348623157e+308 超出这个范围就要算作无穷大了


因此，我们可看出缘由，大数相加出问题是由于精度的不足，小数相加出问题是进制转换时产生误差。第一个好理解，第二个主要是我们常用的十进制转换为二进制时，变成循环小数及无理数等有无限多位小数的数，计算机要用有限位数的浮点数来表示是无法实现的，只能从某一位进行截断。且因为内部表示是二进制，十进制看起来是能除尽的数，往往在二进制是循环小数

比如用二进制来表示十进制的 0.1， 就得写成 2的幂（因为小于1，所以幂是负数）相加的形式。若一直持续下去，0.1就成了0.000110011001100110011... 这种循环小数，在有效范围内进行舍入，就会产生误差。 综上，我们就尽力nag避免小数操作与大数操作，或者转交后台去处理，实在避免不了就引入专业的库来处理。