从一个经常被问到的问题说起：
**从我们打开浏览器输入一个网址到页面显示内容的这段时间内，浏览器和服务端都发生了什么事情？**

* 在接收到用户输入的网址后，浏览器会开启一个线程来处理这个请求，对用户输入的URL地址进行分析判断，如果是HTTP协议就按照HTTP方式来处理                                                                                                                                                                                          
* 调用浏览器引擎中的对应方法， 比如Webview中的loadUrl方法，分析并加载这个URL地址
* 通过DNS解析获取该网站地址对应的IP地址，查询完成后连同浏览器的Cookie、UserAgent等信息向网站目的IP发出GET请求
* 进行HTTP协议会话，浏览器客户端向Web服务器发送报文
* 进入网站后台上的Web服务器处理请求，如Apache、Tomcat、Node.js等服务器
* 进入部署好的后端应用，如PHP、Java、JavaScript、Python等后端程序，找到对应的请求处理逻辑，这期间可能会读取服务器缓存或查询数据库等
* 服务器处理请求并返回响应报文，此时如果浏览器访问过该页面，缓存上对应资源，会与服务器最后修改记录对比，一致则返回304，否则返回200和对应的内容
* 浏览器开始下载HTML文档（响应报头状态码为200时）或者从本地缓存读取文件内容（浏览器缓存有效或响应报头状态码为304时）
* 浏览器根据下载接收到的HTML文件解析结构建立DOM文档树，并根据HTML中的标记请求下载指定的MIME类型文件，同时设置缓存等内容
* 页面开始解析渲染DOM，CSS规则规则解析并结合DOM文档树进行网页内容布局和绘制渲染，JavaScript根据DOM API操作DOM，并读取浏览器缓存、执行事件绑定等，页面整个展示过程完成

整个过程中使用到了较多的浏览器功能，如用户地址栏输入框、网络请求、浏览器文档解析、渲染引擎、JavaScript执行引擎、客户端存储等。


# 浏览器数据持久化存储技术

## HTTP文件缓存

HTTP文件缓存是基于HTTP协议的浏览器端文件级缓存机制。在文件重复请求的情况下，浏览器可以根据HTTP响应的协议头信息判断是从服务器端请求文件还是从本地读取文件

**浏览器HTTP文件缓存判断机制流程**

1. 浏览器会先查询Cache-Control（这里用Expires判断也是可以的，但是Expires一般设置的是绝对过期时间，Cache-Control设置的是相对过期时间）来判断内容是否过期，如果未过期，则直接读取浏览器端缓存文件，不发送HTTP请求，否则进入下一步
2. 在浏览器端判断上次文件返回头中是否含有Etag信息，有则连同If-None-Match一起向服务器发送请求，服务端判断Etag未修改则返回状态304，修改则返回200，否则进入下一步
3. 在浏览器端判断上次文件返回头中是否含有Last-Modified信息，有则连同If-Modified-Since一起向服务器发送请求，服务端判断Last-Modified是否失效，失效则返回200，未失效则返回304
4. 如果Etag和Last-Modified都不存在，直接向服务器请求内容

HTTP缓存可以在文件缓存生效的情况下让浏览器从本地读取文件，不仅加快了页面资源加载，同时节省网络流量，所以在Web站点配置中要尽可能利用缓存来优化请求过程。

<meta http-equiv="Expires" content="Mon, 20 Jul 2017 23:00:00 GMT" />
<meta http-equiv="Cache-Control" content="max-age=7200" />

当然服务端也需要进行对应设置，Node.js服务器可以使用中间件来这样设置静态资源文件的缓存时间，例如可结合Koa和koa-static中间件进行如下设置：

const koa = require('koa')
const static = require('koa-static')
const app = koa()
app.use(static('./pages', {
  maxage: 7200
}))
